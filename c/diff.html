<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Recursive Structure‑Aware Diff Playground</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
 body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:#f5f5f5;margin:0;padding:20px;color:#333}
 h1{text-align:center;margin:0 0 25px;color:#2c3e50}
 textarea{width:100%;min-height:200px;font-family:monospace;font-size:14px;padding:10px;border:1px solid #ccc;border-radius:4px;resize:vertical}
 .grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px}
 button{cursor:pointer;border:none;border-radius:4px;padding:9px 22px;font-size:15px;background:#3498db;color:#fff}
 button:hover{background:#2980b9}
 select{padding:6px 12px;font-size:14px;margin-right:12px}
 .output{background:#fff;border-radius:6px;padding:20px;box-shadow:0 2px 4px rgba(0,0,0,.1)}
 .json{background:#f7f7f7;border-radius:6px;padding:15px;overflow-x:auto;margin-top:15px;font-size:12px}
 /* diff word highlight */
 .word-keep{color:#333}
 .word-delete{background:#ffd4d4;color:#c0392b;text-decoration:line-through;padding:2px 4px;border-radius:3px}
 .word-insert{background:#d4f4dd;color:#2e7d32;padding:2px 4px;border-radius:3px}
 /* table blocks */
 .table-change{margin:12px 0;padding:10px;border-left:4px solid #2196f3;background:#e3f2fd;border-radius:4px;font-size:14px}
 .table-delete{background:#ffebee;border-color:#e53935}
 .table-insert{background:#e8f5e9;border-color:#43a047}
 .table-modify{background:#fff8e1;border-color:#fb8c00}
 /* cell marks */
 .cell-added    {background:#d4f4dd}
 .cell-deleted  {background:#ffd4d4;text-decoration:line-through}
 .cell-modified {background:#fff8e1}
 /* legend */
 .legend{display:flex;flex-wrap:wrap;gap:18px;background:#fafafa;border-radius:6px;padding:15px;margin-bottom:20px}
 .legend span{display:inline-block;padding:2px 8px;border-radius:3px;margin-right:6px}
 .legend .del{background:#ffd4d4}
 .legend .ins{background:#d4f4dd}
 .legend .tbl{background:#e3f2fd}
 /* test suite */
 #tests{margin-top:40px}
 .case{background:#fff;border-radius:6px;padding:15px;margin-bottom:20px;box-shadow:0 1px 3px rgba(0,0,0,.08)}
 .case h3{margin:0 0 8px;color:#555}
 .status{float:right;padding:4px 10px;border-radius:12px;font-size:13px}
 .pass{background:#d4f4dd;color:#27ae60}
 .fail{background:#ffd4d4;color:#c0392b}
 pre{background:#f7f7f7;padding:10px;border-radius:4px;overflow-x:auto;font-size:12px}
</style>
</head>
<body>
<h1>Recursive Structure‑Aware Diff Playground</h1>

<div class="legend">
 <div><span class="del"></span>Deleted word</div>
 <div><span class="ins"></span>Inserted word</div>
 <div><span class="tbl"></span>Table change (insert / delete / modify)</div>
</div>

<!-- Example loader -->
<div style="margin-bottom:12px">
 <select id="exampleSelect"></select>
 <button onclick="loadExample()">Load Example</button>
</div>

<div class="grid">
 <div>
  <h3>Original Document</h3>
  <textarea id="doc1"></textarea>
 </div>
 <div>
  <h3>Modified Document</h3>
  <textarea id="doc2"></textarea>
 </div>
</div>

<button onclick="performDiff()">Calculate Diff</button>

<div id="result" class="output" style="margin-top:25px">
 <em>Diff output appears here…</em>
</div>
<pre id="jsonOut" class="json"></pre>

<!-- TEST SUITE ------------------------------------------------------------->
<div id="tests">
 <h2>Built‑in Test Suite</h2>
 <button onclick="runAllTests()">Run All Tests</button>
 <div id="testResults" style="margin-top:20px"></div>
</div>

<script>
// ===========================================================================
//  Algorithms
// ===========================================================================

class TableDiff{
  constructor(){this.ops=[]}
  diff(html1,html2){
    this.ops=[];
    const d1=this.#arr(html1), d2=this.#arr(html2);
    const colMap=this.#mapCols(d1,d2), rowMap=this.#mapRows(d1,d2,colMap);
    this.#colOps(d1,d2,colMap); this.#rowOps(d1,d2,rowMap); this.#cellOps(d1,d2,rowMap,colMap);
    return this.ops;
  }
  #arr(html){
    const rows=[...new DOMParser().parseFromString(html,'text/html').querySelectorAll('table tr')];
    return rows.map(r=>[...r.children].map(c=>({content:c.innerHTML.trim(),type:c.tagName.toLowerCase()})));
  }
  #mapCols(d1,d2){
    if(!d1.length||!d2.length) return{};
    const h1=d1[0],h2=d2[0],map={};
    h2.forEach((c2,j2)=>{const j1=h1.findIndex(c1=>c1.content===c2.content); if(j1!==-1) map[j1]=j2});
    if(!Object.keys(map).length&&h1.length===h2.length) h1.forEach((_,i)=>map[i]=i);
    return map;
  }
  #rowSim(r1,r2,colMap){
    let m=0,t=0;
    if(Object.keys(colMap).length){
      for(const [j1,j2] of Object.entries(colMap))
        if(r1[j1]&&r2[j2]){t++; if(r1[j1].content===r2[j2].content) m++;}
    }else{
      for(let j=0;j<Math.min(r1.length,r2.length);j++){t++; if(r1[j].content===r2[j].content) m++;}
    }
    return t?m/t:0;
  }
  #mapRows(d1,d2,colMap){
    const map={};
    for(let i2=1;i2<d2.length;i2++){
      let best=-1,score=0;
      for(let i1=1;i1<d1.length;i1++) if(!(i1 in map)){
        const s=this.#rowSim(d1[i1],d2[i2],colMap);
        if(s>score&&s>=.3){score=s;best=i1}
      }
      if(best!==-1) map[best]=i2;
    }
    return map;
  }
  #colOps(d1,d2,colMap){
    const h1=d1[0]||[],h2=d2[0]||[];
    h2.forEach((c2,j2)=>{if(!Object.values(colMap).includes(j2)) this.ops.push({type:'column-add',index:j2,header:c2.content})});
    h1.forEach((c1,j1)=>{if(!(j1 in colMap)) this.ops.push({type:'column-remove',index:j1,header:c1.content})});
    for(const [j1,j2] of Object.entries(colMap)) if(+j1!==+j2) this.ops.push({type:'column-move',from:+j1,to:+j2,header:h1[j1].content});
  }
  #rowOps(d1,d2,rowMap){
    for(let i2=1;i2<d2.length;i2++) if(!Object.values(rowMap).includes(i2))
      this.ops.push({type:'row-add',index:i2,data:d2[i2].map(c=>c.content)});
    for(let i1=1;i1<d1.length;i1++) if(!(i1 in rowMap))
      this.ops.push({type:'row-remove',index:i1,data:d1[i1].map(c=>c.content)});
    for(const [i1,i2] of Object.entries(rowMap)) if(+i1!==+i2)
      this.ops.push({type:'row-move',from:+i1,to:+i2,data:d1[i1].map(c=>c.content)});
  }
  #cellOps(d1,d2,rowMap,colMap){
    const wdiff=new WordLevelStructureDiff();
    for(const [i1,i2] of Object.entries(rowMap)){
      const r1=d1[i1],r2=d2[i2];
      const handle=(j1,j2)=>{
        if(r1[j1]&&r2[j2]&&r1[j1].content!==r2[j2].content){
          const sub=wdiff.diff(r1[j1].content, r2[j2].content);
          this.ops.push({type:'cell-modify',row:+i2,col:+j2,subOps:sub});
        }
      };
      if(Object.keys(colMap).length){
        for(const [j1,j2] of Object.entries(colMap)) handle(j1,j2);
      }else{
        for(let j=0;j<Math.min(r1.length,r2.length);j++) handle(j,j);
      }
    }
  }
}

// ----------------------------------------------------------------------
class WordLevelStructureDiff{
  static WORD=/(\S+)(\s*)/g;
  diff(h1,h2){
    const a=this.#tokens(h1), b=this.#tokens(h2), raw=this.#lcs(a,b);
    return this.#enhance(raw);
  }
  #tokens(h){
    const t=[], parts=h.split(/(<table[\s\S]*?<\/table>)/i); let id=0;
    parts.forEach(p=>{
      if(!p.trim()) return;
      if(/^<table/i.test(p)) t.push({type:'table',html:p,tid:id++});
      else{
        const txt=p.replace(/<[^>]+>/g,'');let m;
        while((m=WordLevelStructureDiff.WORD.exec(txt))) t.push({type:'word',text:m[1]});
      }
    });
    return t;
  }
  #eq(x,y){return (x.type==='word'&&y.type==='word'&&x.text===y.text)||(x.type==='table'&&y.type==='table');}
  #lcs(a,b){
    const n=a.length,m=b.length,dp=Array.from({length:n+1},()=>Array(m+1).fill(0));
    for(let i=n-1;i>=0;i--)for(let j=m-1;j>=0;j--)dp[i][j]=this.#eq(a[i],b[j])?dp[i+1][j+1]+1:Math.max(dp[i+1][j],dp[i][j+1]);
    const ops=[];let i=0,j=0;
    while(i<n&&j<m){
      if(this.#eq(a[i],b[j])) ops.push({type:'keep',a:a[i++],b:b[j++]});
      else if(dp[i+1][j]>=dp[i][j+1]) ops.push({type:'delete',token:a[i++]});
      else ops.push({type:'insert',token:b[j++]});
    }
    while(i<n) ops.push({type:'delete',token:a[i++]});
    while(j<m) ops.push({type:'insert',token:b[j++]});
    return ops;
  }
  #enhance(ops){
    const out=[];
    ops.forEach(o=>{
      if(o.type==='keep'&&o.a.type==='table'){
        const diff=new TableDiff().diff(o.a.html,o.b.html);
        out.push(diff.length?{type:'table-modify',diff,oldHTML:o.a.html,newHTML:o.b.html}:{type:'keep-table',html:o.a.html});
      }else out.push(o);
    });
    return out;
  }
}

// ----------------------------------------------------------------------
function renderTableDiff(ops,oldHTML,newHTML){
  const doc=new DOMParser().parseFromString(newHTML,'text/html');
  const table=doc.querySelector('table'); const rows=[...table.rows].map(r=>[...r.cells]);
  ops.forEach(op=>{
    if(op.type==='row-add') rows[op.index].forEach(td=>td.classList.add('cell-added'));
    if(op.type==='column-add') rows.forEach(r=>r[op.index]?.classList.add('cell-added'));
    if(op.type==='cell-modify'){
      const td=rows[op.row][op.col];
      td.classList.add('cell-modified');
      td.innerHTML=renderDiffHTML(op.subOps);
    }
  });
  ops.filter(o=>o.type==='row-remove').forEach(op=>{
    const tr=table.insertRow();
    op.data.forEach(text=>{
      const td=tr.insertCell(); td.className='cell-deleted'; td.textContent=text;
    });
  });
  ops.filter(o=>o.type==='column-remove').forEach(op=>{
    const cap=table.createCaption(); cap.style.cssText='text-align:left;color:#c0392b;font-size:13px';
    cap.textContent=`⟠ column “${op.header}” removed`;
  });
  return table.outerHTML;
}

function renderDiffHTML(ops){
  return ops.map(o=>{
    if(o.type==='keep'&&o.a?.type==='word') return `<span class="word-keep">${o.a.text}</span>`;
    if(o.type==='delete'&&o.token.type==='word') return `<span class="word-delete">${o.token.text}</span>`;
    if(o.type==='insert'&&o.token.type==='word') return `<span class="word-insert">${o.token.text}</span>`;
    if(o.type==='insert'&&o.token.type==='table') return `<div class="table-change table-insert">[Table inserted]</div>`;
    if(o.type==='delete'&&o.token.type==='table') return `<div class="table-change table-delete">[Table deleted]</div>`;
    if(o.type==='table-modify') return `<div class="table-change table-modify">${renderTableDiff(o.diff,o.oldHTML,o.newHTML)}</div>`;
    if(o.type==='keep-table') return `<div class="table-change">[Table unchanged]</div>`;
    return '';
  }).join(' ');
}

// ===========================================================================
//  UI + examples
// ===========================================================================
const complexH1=`<p>First paragraph stays same.</p>
<p>Second paragraph original content.</p>
<table><tr><th>Name</th><th>Age</th></tr><tr><td>Alice</td><td>30</td></tr><tr><td>Bob</td><td>25</td></tr></table>
<p>Final paragraph unchanged.</p>`;

const complexH2=`<p>First paragraph stays same.</p>
<p>Second paragraph updated content.</p>
<table><tr><th>Name</th><th>Age</th></tr><tr><td>Alice</td><td>30</td></tr><tr><td>Bob</td><td>26</td></tr><tr><td>Charlie</td><td>40</td></tr></table>
<p>Final paragraph unchanged.</p>`;

const recursiveOriginal=`<p>Report<br>Totals:</p>
<table>
 <tr><th>Item</th><th>Details</th></tr>
 <tr><td>Fruit</td><td><ul><li>Apple</li><li>Banana</li></ul></td></tr>
 <tr><td>Veg</td><td><p>Carrot, <strong>Pea</strong></p></td></tr>
</table>`;

const recursiveModified=`<p>Report<br>Totals:</p>
<table>
 <tr><th>Item</th><th>Details</th></tr>
 <tr><td>Fruit</td><td><ul><li>Apple</li><li>Orange</li><li>Banana</li></ul></td></tr>
 <tr><td>Veggies</td><td><p>Carrot, <strong>Peas</strong></p></td></tr>
</table>`;

const EXAMPLES=[
 {name:"Simple Word Replace", doc1:"<p>Hello world</p>", doc2:"<p>Hello there</p>"},
 {name:"Paragraph + Table Mods", doc1:complexH1, doc2:complexH2},
 {name:"Recursive Cell Content", doc1:recursiveOriginal, doc2:recursiveModified}
];

(function populateSelect(){
 const sel=document.getElementById('exampleSelect');
 EXAMPLES.forEach((ex,i)=>{
   const opt=document.createElement('option'); opt.value=i; opt.textContent=ex.name; sel.appendChild(opt);
 });
 sel.selectedIndex=1;
 loadExample();
})();
function loadExample(){
 const idx=+document.getElementById('exampleSelect').value;
 document.getElementById('doc1').value=EXAMPLES[idx].doc1.trim();
 document.getElementById('doc2').value=EXAMPLES[idx].doc2.trim();
}

function performDiff(){
 const h1=document.getElementById('doc1').value, h2=document.getElementById('doc2').value;
 if(!h1||!h2){alert('Enter both documents');return;}
 const ops=new WordLevelStructureDiff().diff(h1,h2);
 document.getElementById('result').innerHTML=renderDiffHTML(ops);
 document.getElementById('jsonOut').textContent=JSON.stringify(ops,null,2);
}

// ===========================================================================
//  Tests – updated expectations use subOps
// ===========================================================================
const tableTests=[{
  name:"Cell change", t1:"<table><tr><th>N</th><th>A</th></tr><tr><td>J</td><td>30</td></tr></table>",
  t2:"<table><tr><th>N</th><th>A</th></tr><tr><td>J</td><td>31</td></tr></table>",
  expect:[{type:"cell-modify",row:1,col:1}]
}];

const wordTests=[{
  name:"Recursive cell change", h1:recursiveOriginal, h2:recursiveModified,
  wordDel:["Veg"], wordIns:["Veggies","Orange"]
}];

function compareOps(actual,expected){
 return expected.every(e=>actual.some(a=>Object.keys(e).every(k=>a[k]===e[k])));
}

function injectCase(t,ok,det){
 const d=document.createElement('div');d.className='case';
 d.innerHTML=`<h3>${t}<span class="status ${ok?'pass':'fail'}">${ok?'PASS':'FAIL'}</span></h3>
 <pre>${JSON.stringify(det,null,2)}</pre>`;
 document.getElementById('testResults').appendChild(d);
}

function runAllTests(){
 const tr=document.getElementById('testResults');tr.innerHTML='';let p=0,f=0;
 tableTests.forEach(tc=>{
   const ops=new TableDiff().diff(tc.t1,tc.t2);
   const ok=compareOps(ops,tc.expect);
   injectCase(tc.name,ok,{ops:ops.slice(0,10)});
   ok?p++:f++;
 });
 wordTests.forEach(tc=>{
   const ops=new WordLevelStructureDiff().diff(tc.h1,tc.h2);
   const dels=ops.flatMap(o=>o.type==='delete'&&o.token?.type==='word'?[o.token.text]:[]);
   const ins =ops.flatMap(o=>o.type==='insert'&&o.token?.type==='word'?[o.token.text]:[]);
   const ok=tc.wordDel.every(w=>dels.includes(w))&&tc.wordIns.every(w=>ins.includes(w));
   injectCase(tc.name,ok,{dels,ins});
   ok?p++:f++;
 });
 tr.insertAdjacentHTML('afterbegin',`<div style="margin-bottom:15px;font-size:18px">
  Passed <b style="color:#27ae60">${p}</b> | Failed <b style="color:#c0392b">${f}</b>
 </div>`);
}
</script>
</body>
</html>
